#如何学习 TCP　协议

##入门

##理解概念

TCP 提供一种面向连接的,可靠的,字节流服务.

**面向连接**

两个使用 TCP 的应用在彼此交换数据之前必须建立连接, 对比 UDP

**可靠**

传输前: 数据分片
传输中: 超时重传,流量控制
传输后: 首部校验,失序重排,去重,确认

**字节流服务**

两个应用通过 TCP 连接交换 8 bit构成的字节流. TCP 不在字节流中插入记录标志符,不对字节流内容作任何解释

此外, TCP 为应用层提供全双工服务, TCP 为一个没有选择确认,没有选择否认的滑动窗口协议

##协议格式

![TCP报文首部](tcp_format.png)

##基本原理

###从连接建立,传输数据,到断开连接的状态变化

![TCP连接过程](tcp_process.jpg)

###连接建立之三次握手过程

####为什么是三次, 不是两次, 四次或更多 ?

要正确回答这个问题, 首先要理解对可靠的约束, TCP 每次发送都是需要对端确认的, 而 UDP 就不需要, 这就本身
表明 TCP 较 UDP 是可靠的. 我相信刨根问底的你, 绝对不会满足这样的回答, 我们继续探讨.

建立连接的过程

1 客户端首先发送请求,请求连接服务器, 等待服务器应答
2 服务器收到客户端请求, 发送应答给客户端
3 服务器发送请求, 告诉客户端已经准备好了
4 客户端收到服务器请求, 发送服务器已经收到

从这里看应该是四次数据交互怎么就成了三次呢? 这里关键是, 将服务器的接受客户端请求, 发送应答, 与发送请求
合并在一起了, 因此, 就减少了一次数据传送, 变成三次. 同理, 关闭连接也是这样, 但是关闭为什么不能是三次呢?
且待下文分析

再回到可靠性上, 到这里, 一定有人在想, 一请一答怎么可能可靠呢?

* 问题一: 如果客户端发送的请求服务的没有收到怎么办?
* 问题二: 如果服务器的应答客户端没收到怎么办?

这不是无穷递归了么? 事实上, 这个问题是不存在的, 原因是, 客户端通过超时来确定请求是否到达客户端, 如果
在一定时间内没有收到服务器的应答, 客户端会重新发送之前的请求, 经过一定的重试次数后，仍然不能成功, 就认为
服务器连接失败, 因此通过超时机制, 只要客户端和服务器是网络可达的, 服务器就一定能收到客户端的请求.
在看问题二, 服务器收到客户端的请求后发送应答, 是不是和问题一的思路一样, 是的, 服务器给客户端发送应答
也是利用超时机制来解决客户端的接收问题. 关于超时机制, 后文会详述.

当然, 至此, 问题似乎已经解决, 其实还没有, 因为, 假设客户端发送请求, 服务器收到了, 服务器发送应答, 客户端
也收到了, 问题是服务器如何确定客户端收到了呢? 是不是要客户端继续发送收到服务器的应答了呢? 这不是还是在
无限循环中么?

这个问题解决办法就是通过发送请求的序列号, 客户端发送请求报文中序列号 N, 服务器收到后应答包中加入 M ACK N+1,
客户端收到服务器的应答报文后, 通过查看 ACK N+1 知道服务的已经收到客户端发送 N 的请求, 发送 N+1:N+X,ACK M+1,
服务器收到客户端的 ACK M+1 知道客户端已经收到服务器的请求, 无限递归问题解决, 两端成功建立连接.

现在你看看上图建立连接的部分是什么样的感觉 ? 顺便思考下, 两次是否可以成功握手, 三次以上就不要考虑了, 因为三
次可以, 你为什么需要四次.

至此, 你已经充分理解, 三次握手是不多不少, 多了是浪费, 少了就不能可靠传输.

当然, 你还会发现 TCP 包首部的 32 位序号和 32 位的确认序号绝不是多余. 这里 32 位长度, 事实上, 在现在的情况下,
32 位长度在有些场合已经遇到瓶颈. 后文再表

###四次断开连接

####为什么是四次结束, 三次不可以么 ?

先看看断开连接的过程:

1 客户端发送 FIN, 表明自己数据已经发送完了(这时客户端还可以接受服务器的数据)
2 服务器收到客户端的 FIN, 应答之
3 服务器的发送 FIN, 表明自己的数据发送完了
4 客户端收到服务器的 FIN, 应答之.

四次, 这里的2, 3 可以合并么? 不可用, 因为, 服务器收到客户端的 FIN, 这时,
服务器可能还有数据要发送, 但数据没有准备好, 于是先把应答发给客户端. 所以2, 3
无法合并. 那为什么握手的2,3可以合并呢? 原因是, 握手时, 双方主要工作是建立连接,
2, 3 之间, 服务器不需要等待或依赖什么, 因此, 2,3 可以合并.

还有一个疑问是, 服务器完全可以等自己的数据准备好了, 再发送应答啊, 这样不就可以
减少为 3 次了么?

TIPS: 对于四次握手, 很多人感觉太冗余了, 因此, 现在很多应用直接 RST 断开连接, 干脆利落

###能读懂 wireshark 中与 TCP 协议相关的所有字段

了解三次握手, 四次分手, 我们来看看, 实际中网络通信的过程, 当然, 神器就是 tcpdump
和 wireshark

####建立连接

方式:

* 一方主动打开,另一方被动打开
* 双方都主动打开

####断开连接

方式:

* 一方主动关闭,另一方被动关闭
* 双方都主动关闭

* Seq: 最大为 2^32-1, 到达最大值后从 0 开始
* MSS(Maximum Segment Size) : 发送方指明本端能接受的最大报文长度,
通常在通信的第一个报文中指明该字段, 如果一方不接受另一方的 MSS 大小, 默认是 536,
以适应 576 的 IP报文(536 + TCP头 + IP头), 以太网中该值可以为 1460(1500-40)
* SYN: 开始建立连接的第一个包, SYN 置 1
* ACK: 连接建立后,一直为 1, 在应答序列号只有在 ACK 为 1 时才有效
* FIN: 发送端完成数据发送
* RST: 重建连接
* Win: 发送方希望下次接收的数据长度阈值, 最大窗口为 65535, 在现代的网络中, 有时候已经遭遇瓶颈
* URG: 置 1 时, 紧急指针才有效
* PSH: 接收方应该尽快将这个报文交给应用程序, 发送方无法通过编程来设置, 当缓存区清空的时候, 协议栈自动会设置该标志位

###TCP 状态转换

![TCP状态机](tcp_state.gif)

![TCP状态机](tcp_state.png)

![TCP状态机](tcp_state1.png)

###客户端主动打开, 服务端被动打开

1  客户端发送 SYN 未收到 ACK 时,进入 SYN_SENT
2  服务器收到 SYN, 发送 SYN, ACK 进入 SYN_RCVD
3  客户端收到服务器 ACK, 以及服务器发送的 SYN 后, 发送 ACK 后, 进入 ESTABLISHED
4  服务器收到 ACK, 不发送, 进入 ESTABLISHED
5  客户端和服务器收发数据
6  客户端发送 FIN, 进入 FIN_WAIT_1
7  服务器收到 FIN, 发送 ACK, 进入 CLOSE_WAIT
8  客户端收到 ACK, 不发送, 进入 FIN_WAIT_2
9  服务器发送 FIN, 进入 LAST_ACK
10 客户端收到 FIN, 发送 ACK， 进入 TIME_WAIT
11 服务器收到 ACK, 进入 CLOSED
12 2MSL 超时后进入 CLOSED

###异常情况

1  客户端发送 SYN 未收到 ACK 时,进入 SYN_SENT
2  服务器收到 SYN, 发送 SYN, ACK 进入 SYN_RCVD
3  客户端发送 RST
4  服务端收到 RST, 返回 LISTEN 状态, 等待另一个连接请求到来

###2MSL

当一个 TCP 执行主动关闭, 并发回最后一个 ACK, 该连接必须在 TIME_WAIT 状态停留的时间为 2 倍的 MSL.
这样的好处是让 TCP 再次发送最后一个 ACK 以防这个 ACK 丢失(另一端超时并重传最后的FIN), 缺点是直到
2MSL 结束 这个 TCP 连接在 2MSL 等待期间, 不能再被使用, 一般 2MSL 为 4 分钟,实现常是 1 分钟或 30 秒

1. 如果是客户端执行主动关闭, 2MSL 没有什么影响, 因为客户端不会端口重用,而且端口是不固定的
2. 如果是服务端主动关闭, 2MSL 就可能产生影响, 因为服务器一般都是绑定到固定端口

####验证

1. 服务器启动一个服务(绑定 8000 端口), 客户端连接服务器, 然后停止服务, 重启服务
2. 客户端连接服务器绑定到固定端口(9000), 连接服务器, 然后, 关闭客户端, 重新连接服务器
3. 服务器启动服务(绑定8000d端口), 客户端绑定(9000)端口, 连接服务器, 主动关闭服务器, 然后以服务器的
8000 端口为客户端, 客户端的 9000 端口为服务端口, 服务器连接客户端的 9000 端口
4. 在 3 中，服务器连接客户端的时候打开 SO_REUSEADDR
5. 在 1 中, 启动服务器时打开 SO_REUSEADDR.

###RST

* 到不存在的端口
* 异常终止一个连接 SO_LINGER
* 半打开连接: 客户端掉电, 服务器重启,客户端重新发送数据

半关闭: 例如远程执行命令
平静时间:
同时打开: 既是服务器又是客户端
同时关闭: 同时 FIN
TCP 选项:

**注**

* MSL(Maximum Segment Lifetime)
* 两个导致进入 ESTABLISHED 的状态变迁对应打开一个连接, 两个导致从 ESTABLISHED 离开的变迁对应关闭一个连接
* CLOSED 不是一个真正的状态, 而是一个假想的起点和终点


此外, 还有如下零碎的知识点;

1. src_ip, src_port, dst_ip, dst_pot 为四元组, 唯一标志一个 TCP 连接
2. src_ip, src_port, protocol, dst_ip, dst_port 为我们常说的五元组, 唯一标志一个连接
3. 连接建立开始的序号叫 ISN (initial Sequence Number), 即初始序列号, 绝不是从抓包软件中看到的从 0 开始, 此外这个需要是 2的 32 次方
4. 连接建立和连接终止时, TCP 数据部分为 0, 因此 TCP 报文数据部分是可选的
5. 校验和是强制性的
6. 首部没有可选字段, 为20 个字节, 包含可选字段最大为 60 字节(4 * 15)
7. TCP 接受一个连接将其放入队列, 而应用层接受连接是将其从队列中取出
8. TCP 确认仅仅表明TCP已经正确接受了数据




至此, 你可以在简历上说了解 TCP 了. 但要说熟悉, 还需要下文的帮助

##熟悉

##TCP 窗口

* MTU
* MSS
* 发送窗口
* 接受窗口: 也叫通告窗口,可变,即滑动窗口, 接收方的流量控制
* 拥塞窗口cwnd: 发送方的流量控制
* 路径MTU
* 延迟确认
* Nagle算法
* 滑动窗口: 窗口张开, 窗口合拢, 窗口收缩

它们相互之间的关系

 MTU = MSS + 40

##重传

* RTT:
* 慢启动: 每收到 n 个确认就把拥塞窗口增加 n 个 MSS
* 拥塞避免: 慢启动到达临界窗口值，每个往返时间增加 1 个 MSS
* 超时重传: 拥塞避免阶段
* 超时重传对拥塞窗口和临界窗口值的影响 : 临界窗口值为没有确认包的数据量的 1/2 (不小于 2 MSS), 拥塞窗口降为 MSS
* RTO 计算方法 A+2D -> A+4D
* 快速重传: 拥塞避免阶段,收到 3 个重复的 ack(表明包丢了); 为什么要 3 个，完全是经验值，为了与乱序区别开来
* 快速重传对拥塞窗口和临界窗口值的影响 : 快速恢复
* 快速恢复: 临界窗口值为没有确认包的数据量的 1/2 (不小于 2 MSS), 拥塞窗口设置为临界窗口值加 3, 继续保留在拥塞避免阶段

* 延迟确认: 收到数据后直到有数据要回复或者延迟一定时间(200ms)，才确认
* Nagle 算法: 收到数据后直到有数据要回复或者数量满 1 个MSS，才确认, (TCP_NODELAY 关闭该算法)
* 糊涂窗口综合症: 窗口更新发生于窗口大小增加了两个 MSS 或最大接受窗口的 1/2 时,发送窗口更新

##临界窗口的确认

* RFC 2001 丢包时的一半大小
* Westwood : 作者Saverio Mascolo, 适用于经常发送非拥塞性的丢包环境(无线)
* Vega : 通过 RTT 来调整临界窗口值
* Compound : Windows
* BIC
* CUBIC


对于多个丢包, 更好的解决办法:

* NewReno: RFC 2582, RFC 3782
* SACK   : RFC 2018


##参考

* RFC5681
* TCP/IP 详解卷一
* Wireshark 网络分析就这么简单
[RFC 793](http://www.cs.northwestern.edu/~kch670/eecs340/proj2-TCP_IP_State_Transition_Diagram.pdf)
