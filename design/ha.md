#高可用

以下仅针对一主一从, 如果需要一主多从, 机器高可用需要其他协议来保证, 如 zookeeper. 而存储高可用只需要简单调整.

###前提

####时间同步

两台 A5 直接的时间必须同步误差在秒级. 主要是为了缓存过期清除, 此外每次进行负载均衡决策时都会检查缓存是否过期.

####缓存数据量的估计

每个条缓存数据包含 vip:port-cip:port-sip:port 以 ip 和端口都是 Integer 类型, 以字符- 和 : 分割

以每秒 100000 并发, 缓存过期时间为 3600 s. 大约为 3.6 亿条. 3.6 * 30 = 9 600 000 000 bit 即大约 10G 内存

因此需要内存至少在 30 ~ 40 G 以上(流表在 ovs 缓存也需要内存).

以上只是一个预估, 实际远远不会由这么多的请求数. 内存目前的价格大约是 70 元/G, 因此我们可以更加支持的并发数定价.

此外, 根据经验值:

* 主存 IOPS 千万级, 
* SSD盘 IOPS 万级别(35000)
* 网络 IO 万级别

由于我们的数据量基本单机的内存或磁盘是可以满足的, 因此, 我们基本不希望将缓存数据进行跨机访问. 但是, 为了数据一致性,
我们必须以牺牲性能为代价.

##机器的高可用

主从切换通过 VRRP 协议保证主从切换的可靠性, 目前这是非常成熟的技术, 而且之前的测试已经表明可以工作.

##存储的高可用

核心思想是复制.

可能存在问题:

1. Master 服务器宕机
2. Slave 服务器宕机
4. Master 服务器保存缓存数据的进程挂掉
4. Slave 服务器保存缓存数据的进程挂掉
5. Master 和 Slave 发生网络异常

为了避免一主一从同时宕机, 以及在从未完成完全同步之时主宕机, 需引入一主多从

###方案一

Master 服务器定期将缓存数据写入本机磁盘; Slave 服务器通过 TCP 读取 Master 服务器保存在磁盘的缓存数据, 保存在本机内存和磁盘

每台服务器保存缓存三份, 一份是流表, 一份在控制器进程, 一份在磁盘.

**注**

Slave 服务器每次向 Master 服务器读取数据都会将已经读成功的数据偏移传递给 Master服务器.
Master 服务器根据偏移将下一批数据传递给 Slave 服务器.

####Master 服务器宕机

Master 服务器宕机时尝试将内存数据写入磁盘, 没有写入磁盘的缓存数据丢失. Master 服务器重启后角色变为 Slave, 从头开始读取当前 Master 的数据.

Slave 服务器角色变为 Master. (可选: 待之前 Master 服务器重启后, 继续读取之前磁盘的数据, 完成后, 删除该数据.)

####Slave 服务器宕机

Slave 服务器重启后, 读取本地磁盘到内存, 之后根据本机已经同步的数据之后的位置开始读取 Master 服务器数据.

####Master 服务器保存缓存数据的进程挂掉

对应该方案, 相当于控制器挂掉, 有两种解决办法:

1) 控制器立即重启, 之后将读磁盘缓存数据到内存, 开始服务.
2) 进行角色切换, 见本方案 "Master 服务器宕机"

####Slave 服务器保存缓存数据的进程挂掉

对应该方案, 相当于控制器挂掉, 控制器立即重启, 之后将读磁盘缓存数据到内存, 继续从 Master 服务器同步缓存数据.

####主从发生网络异常

网络恢复后, Slave 继续从 Master 读取.

###方案二

Master 服务器将缓存数据写入队列, (可选:并定期同步到磁盘); Slave 服务器通过 TCP 读取主服务器队列的缓存数据, 同时保持在本机队列和磁盘(可选)

目前缓存相当于存四份, 一份是流表, 一份在控制器进程, 一份在队列进程, 一份在磁盘(可选)

以队列形式保存的缓存数据与控制器可以不在同一个进程, 因此缓存保存在两个进程, 分别为控制器进程和队列进程

####Master 服务器宕机

Master 服务器宕机时尝试将内存数据写入磁盘, Master 服务器重启后角色变为 Slave, 从头开始读取当前 Master 的数据.

Slave 服务器角色变为 Master.

####Slave 服务器宕机

Slave 服务器重启后, 从头开始读取 Master 服务器数据.

####Master 服务器保存缓存数据的进程挂掉

对应该方案, 包括控制器挂掉和队列进场挂掉两种情况:

1) 控制器挂掉有两种方法:

* 控制器控制器立即重启, 之后将读队列进程数据到内存, 开始服务.(推荐)
* 进行角色切换, 见本方案 "Master 服务器宕机"

2) 队列进程挂掉

停止响应 Slave 服务器的请求, 重启后从控制器缓存读数据到队列.之后开始响应 Slave 服务器数据.

####Slave 服务器保存缓存数据的进程挂掉

对应该方案, 包括控制器挂掉和队列进场挂掉两种情况:

1) 控制器挂掉, 控制器立即重启, 之后将读磁盘缓存数据到内存, 继续从 Master 服务器同步缓存数据.

2) 队列进程挂掉, 从缓存进程读取, 之后继续从 Master 同步缓存数据

####主从发生网络异常

网络恢复后, Slave 继续从 Master 读取.

###方案三

主服务器将缓存数据直接同步发送给从服务器, 待从服务器返回成功后, 继续后续处理. 此外, 主服务器和从服务器都将数据定期持久化到磁盘

####Master 服务器宕机

Master 服务器重启后角色变为 Slave. 从头开始读取当前 Master 的数据

Slave 服务器角色变为 Master

####Slave 服务器宕机

Slave 服务器重启后. 从头开始读取当前 Master 的数据

####Master 服务器保存缓存数据的进程数据挂掉

两种办法
1) Master 服务器重启后. 从头开始读取当前 Slave 的数据, 之后开始对外提供服务
2) Master 进行角色切换, 见本方案"Master 服务器宕机"

####Slave 服务器保存缓存数据的进程挂掉

Slave 服务器重启后. 从头开始读取当前 Master 的数据

####主从发生网络异常

网络恢复后, Slave 继续从 Master 读取.

##总结

性能从高到低: 方案二 >> 方案一 > 方案三

一致性从高到低: 方案三 > 方案二 >> 方案一


附录:

java 每秒写 ConcurrentHashMap

JVM 参数: /opt/jdk1.7.0_79/jre/bin/java -server -Xms1024M -Xmx1024M

60000       72
600000      316
1200000     626
1800000     1279
2400000     1269
3000000     1868
3600000     2137

ssdb 每秒写 String, String

JVM 参数: /opt/jdk1.7.0_79/jre/bin/java -server -Xms1024M -Xmx1024M

6000       503
12000      865
18000      1329
24000      1471
30000      2104
36000      2072
42000      2675
48000      2628
54000      3216
60000      3224
